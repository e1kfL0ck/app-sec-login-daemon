\documentclass[11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[margin=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage{svg}

\title{Application Security -- Laboratories\\[0.4em]
\large LAB-03 and LAB-04}
\author{Gaillard Théo \\ \texttt{theo.gaillard@student.put.poznan.pl} \\
Quivron Emile \\ \texttt{emile.quivron@student.put.poznan.pl} \\
\\
Supervisor: Michał Apolinarski, Ph.D. \\ Politechnika Poznańska}
\date{\today}

\begin{document}
\maketitle

This document consists of two main parts:
\begin{itemize}
  \item LAB-03: user registration process.
  \item LAB-04: login and session management module.
\end{itemize}

\section*{Component Short Description}
The user registration module is a secure software component responsible for creating new user accounts within the system.
Its primary purpose is to allow new users to provide personal and authentication information, validate that information securely on the server side, and store the finalized account data in the application database.

\subsection*{Collected data}
The component collects the following data from the user during registration:
\begin{itemize}
  \item Email address -- used as the unique identifier for the account and for sending activation tokens.
  \item Password -- chosen by the user and processed using strong hashing before storage.
  \item Optional user metadata -- such as username or full name, depending on system requirements.
\end{itemize}

\subsection*{Security assumptions and objectives}
\begin{itemize}
  \item The server is assumed to operate over a secure HTTPS channel to ensure confidentiality during transmission.
  \item All data submitted by users is considered untrusted and must be validated server-side to prevent injection attacks, malformed input, or exploitation attempts.
  \item Passwords must never be stored in plain text; they are protected using a secure one-way hashing function with salting.
  \item A unique activation token is generated for each new registration to confirm ownership of the provided email address.
  \item The module supports error handling and defensive measures throughout the process, including input validation, token verification, storage integrity constraints, and optional security hardening (rate limiting, advanced password policies, and event logging).
\end{itemize}

\section*{Component Requirements}
\subsection*{Functional Requirements}
\begin{description}
  \item [FR-01] The system must provide a user registration form for entering required data.
  \item [FR-02] The server must validate all submitted fields for correctness, integrity, and constraints.
  \item [FR-03] The system must verify that the email address is not already registered.
  \item [FR-04] The system must hash passwords securely before storing them.
  \item [FR-05] The system must generate a unique account activation token after registration.
  \item [FR-06] The system must send an activation link containing the token to the user’s email address.
  \item [FR-07] The system must activate the account by validating the token upon request.
  \item [FR-08] The system must handle invalid or expired tokens with clear error messages.
  \item [FR-09] The module must store user data (email, hashed password, token status, timestamps).
  \item [FR-10] The system should log validation or activation errors.
\end{description}

\subsection*{Optional Functional Requirements (Bonus Features)}
\begin{description}
  \item [OFR-01] Display a password strength meter during user input.
  \item [OFR-02] Enforce an advanced password policy (length, complexity, blacklist, etc.).
  \item [OFR-03] Perform email verification through DNS MX lookup or SMTP handshake.
  \item [OFR-04] Apply email domain restrictions via whitelist or blacklist.
  \item [OFR-05] Support registration using invitation tokens.
  \item [OFR-06] Implement CAPTCHA or rate limiting to prevent automated or abusive submissions.
  \item [OFR-07] Improve activation token security (short lifetime, association with device/IP, etc.).
  \item [OFR-08] Log successful and failed registration attempts as security events.
\end{description}

\subsection*{Non-Functional Requirements}
\paragraph{Security Requirements}
\begin{description}
  \item [NFR-S01] Passwords must be stored using secure, modern cryptographic hashingitemize.
  \item [NFR-S02] Sensitive information (passwords, tokens) must not be logged.
  \item [NFR-S03] All communication between client and server should use HTTPS.
\end{description}

\paragraph{Usability Requirements}
\begin{description}
  \item [NFR-U01] Error and validation messages from the frontend must be clear and user-friendly.
  \item [NFR-U02] Registration should require no more than one user interaction step before activation.
\end{description}

\paragraph{Performance Requirements}
\begin{description}
  \item [NFR-P01]: Registration requests should be processed with low latency.
  \item [NFR-P02]: The system should scale to the required number of concurrent registrations.
\end{description}

\paragraph{Reliability Requirements}
\begin{description}
  \item [NFR-R01]: Duplicate account creation with the same email must be prevented.
  \item [NFR-R02]: Activation tokens must have a configurable expiration period.
  \item [NFR-R03]: Token validation must fail safely in cases of expiration or tampering.
\end{description}

\paragraph{Maintainability Requirements}
\begin{description}
  \item [NFR-M01]: The module must be structured with separate layers for validation, logic, and data access.
  \item [NFR-M02]: Configuration values must be stored in an accessible JSON configuration file.
\end{description}

\section*{Tech Stack}
\subsection*{Frontend}
\begin{itemize}
  \item HTML5 and CSS3: For building the registration and activation pages.
  \item JavaScript: Handles client-side input validation (email format, password strength meter, etc.).
  \item Optional: Bootstrap or TailwindCSS for quick UI styling and responsive layouts.
\end{itemize}

\subsection*{Backend}
\begin{itemize}
  \item Python 3: Core application logic and registration workflows run here.
  \item Flask: Web framework for routing (e.g., \texttt{POST /register} and \texttt{GET /activate/<token>}), input validation, and returning HTML or JSON responses.
\end{itemize}

\subsection*{Security \& Cryptography}
\begin{itemize}
  \item \texttt{bcrypt}: For secure password hashing with salt.
  \item \texttt{secrets} (Python standard library): For generating secure random activation tokens.
\end{itemize}

\subsection*{Database}
\begin{itemize}
  \item SQLite3: local file-based relational database accessed using Python's built-in \texttt{sqlite3} module.
  \item Example tables and columns:
        \begin{itemize}
          \item \texttt{users}: \\
                exttt{id}, \texttt{email}, \texttt{password\_hash}, \\
                exttt{last\_login}, \texttt{nb\_failed\_logins}, \\
                exttt{created\_at}, \texttt{activated} (0/1)
          \item \texttt{tokens}: \\
                exttt{token}, \texttt{user\_id}, \texttt{expires\_at}, \\
                exttt{created\_at}, \texttt{type} (``activation'' / ``password\_reset'')
        \end{itemize}
  \item Constraints should ensure unique emails, token expiration rules, and referential integrity.
\end{itemize}

\subsection*{Web Server}
\begin{itemize}
  \item \texttt{nginx} as reverse proxy to the Python application (via Gunicorn); serves static files and handles TLS termination.
\end{itemize}

\section*{UML Diagrams}
\subsection*{User Form Filling Process}
\includegraphics[width=\textwidth]{img/UML_FormFilling.pdf}

\subsection*{User Registration Process}
\includegraphics[width=\textwidth]{img/UML_Register.pdf}

\subsection*{Token Validation Process}
\includegraphics[width=\textwidth]{img/UML_ActivationToken.pdf}

\section{User registration flow presented}

When a user wants to register on our platform, they will first access the registration page served by our Flask backend. The user fills out the registration form with their email and password. On the client side, JavaScript performs preliminary validation checks, such as ensuring the email format is correct and the password meets basic strength requirements. This immediate feedback enhances user experience by catching simple errors before submission.

Here's an example of the potential errors :

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{img/registration_errors_client.png}
  \caption{Example of validation error messages shown to the user during registration (email format, password strength, and required fields).}
  \label{fig:registration_errors}
\end{figure}

Once the user submits the form, the data is sent via a POST request to the Flask backend at the \texttt{/register} endpoint. The backend performs comprehensive server-side validation to ensure all fields are correct. This includes checking that the email format is valid, that it does not contain dangerous patterns (to prevent attacks), verifying that the password meets security policies (length, complexity). Then, the backend will try to save this new user in the database, ensuring the email is unique. The database also contains the user activation status. If any validation fails, the backend responds with appropriate error messages, which are then displayed to the user.

If the email is already registered here's the error message shown to the user :

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{img/registration_error_email_exists.png}
  \caption{Error message shown to the user when trying to register with an already registered email.}
  \label{fig:registration_error_email_exists}
\end{figure}

Upon successful validation and user creation, the backend generates a unique activation token using Python's \texttt{secrets} module.
This token is stored in the database along with an expiration timestamp and the user id associated with it.
This token is then sent to the user by email in order to provide the activation workflow.

Example of token being displayed to the user after successful registration :
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{img/registration_success_mail.png}
  \caption{Example of registration confirmation message upon successful registration.}
  \label{fig:registration_success_mail}
\end{figure}

When the user clicks the activation link, it sends a GET request to the \texttt{/activate/<token>} endpoint on the backend. The backend retrieves the token from the URL, validates it against the database (checking for existence and expiration), and if valid, updates the user's activation status to true. The user is then informed of the successful activation.

Example of successful activation message shown to the user :
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{img/activation_success.png}
  \caption{Example of successful activation message shown to the user.}
  \label{fig:activation_success}
\end{figure}

If the token is invalid or expired, the backend responds with an error message, which is displayed to the user.

Example of error message shown to the user when trying to activate with an invalid or expired token :
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{img/invalid_token.png}
  \caption{Example of error message shown to the user when trying to activate with an invalid or expired token.}
  \label{fig:activation_error_invalid_token}
\end{figure}


\section*{Why do we perform both frontend and backend validation?}

In the user registration process, we implement validation checks on both the frontend (client-side) and backend (server-side) for complementary reasons. Frontend validation provides immediate user feedback, improving UX by catching simple errors like password length or format issues before submission. It reduces unnecessary server requests and guides users to correct their input quickly.

However, frontend checks can be bypassed: attackers can disable JavaScript or manipulate requests directly. Backend validation is our security layer, defending against SQL injection, XSS, and malicious payloads. It enforces business rules and data integrity regardless of client behavior.

For example, our \texttt{validation.js} validates email format client-side:
\begin{verbatim}
const re = /^[^@\s]+@[^@\s]+\.[^@\s]+$/;
if (!re.test(email)) {
    errors.push("Email format is invalid.");
}
\end{verbatim}

While our \texttt{app.py} backend sanitizes and re-validates server-side:
\begin{verbatim}
def sanitize_user_input(field_value: str, max_len: int = 255):
    if contains_dangerous_pattern(field_value):
        errors.append("User input error.")
\end{verbatim}

The frontend enhances usability; the backend ensures security. Both working together create a robust system: fast feedback for legitimate users, strong protection against attackers. Never trust client-side validation alone: our backend is the final authority.

\noindent\rule{\textwidth}{1pt}

\section*{Login and Session Management Module (LAB-04)}

\subsection*{Component Short Description}
The login and session management module extends the registration system by enabling authenticated user access and secure password recovery.
Its primary purpose is to verify user credentials, establish and maintain secure sessions, and provide a mechanism for users to securely reset forgotten passwords.

\subsection*{Collected data}
The component collects the following data from the user during login:
\begin{itemize}
  \item Email address: used as the unique identifier for the account and for authentication.
  \item Password: used by the user to authenticate and establish a session.
\end{itemize}

\subsection*{Security assumptions and objectives}
\begin{itemize}
  \item The server is assumed to operate over a secure HTTPS channel to ensure confidentiality during transmission.
  \item All data submitted by users is once again considered untrusted and must be validated server-side to prevent injection attacks, malformed input, or exploitation attempts.
  \item Passwords must never be stored in plain text; they are protected using a secure one-way hashing function with salting.
  \item User sessions must be managed securely using server-side session tokens with appropriate expiration policies.
  \item Authentication credentials (email and password) must be verified against stored hashed values without exposing timing vulnerabilities.
  \item Password reset tokens must be cryptographically secure, single-use, and time-limited to prevent unauthorized account access.
  \item The module supports error handling and defensive measures throughout the process, including input validation, session management, password verification, storage integrity constraints, and optional security hardening (rate limiting, CAPTCHA, and event logging).
\end{itemize}

\section*{Component Requirements}
\subsection*{Functional Requirements}
\begin{description}
  \item [FR-01] The system must provide a user login form for entering email and password.
  \item [FR-02] The server must validate all submitted login credentials for correctness and format.
  \item [FR-03] The system must verify submitted credentials against stored hashed passwords.
  \item [FR-04] The system must generate a secure session token upon successful authentication.
  \item [FR-05] The system must store session tokens server-side with appropriate expiration times.
  \item [FR-06] The system must validate session tokens on protected routes and endpoints.
  \item [FR-07] The system must provide a logout mechanism that invalidates the current session.
  \item [FR-08] The system must provide a password reset request form accepting email address.
  \item [FR-09] The system must generate a unique, time-limited password reset token.
  \item [FR-10] The system must send a password reset link containing the token to the user's email when requested.
  \item [FR-11] The system must validate password reset tokens before allowing password changes.
  \item [FR-12] The system must allow users to set a new password using a valid reset token.
  \item [FR-13] The system must invalidate password reset tokens after successful use or expiration.
  \item [FR-14] The system must handle invalid login attempts with generic error messages.
  \item [FR-15] The system must handle expired or invalid sessions by redirecting to login.
\end{description}

\subsection*{Optional Functional Requirements (Bonus Features)}
\begin{description}
  \item [OFR-01] The system may implement rate limiting on login attempts per IP address or user account.
  \item [OFR-02] The system may implement CAPTCHA verification after a threshold of failed login attempts.
  \item [OFR-03] The system may log successful and failed authentication events for security auditing.
  \item [OFR-04] The system may implement "remember me" functionality with secure long-lived tokens.
  \item [OFR-05] The system may notify users via email of successful login from new devices or locations.
  \item [OFR-06] The system may implement multi-factor authentication (MFA) for enhanced security.
  \item [OFR-07] The system may enforce password expiration policies requiring periodic password changes.
  \item [OFR-08] The system may implement account lockout after consecutive failed login attempts.
\end{description}

\subsection*{Implementation of the 2FA module}
We have implemented a basic Multi-Factor Authentication (MFA) module using Time-based One-Time Passwords (TOTP) as an optional bonus feature (OFR-06).
When a user enables MFA in their account settings, the system generates a unique TOTP secret key for that user using the \texttt{pyotp} library.
This secret is then presented to the user as a QR code (using the \texttt{qrcode} library) that they can scan with an authenticator app (e.g., Google Authenticator, Authy).
During login, after the user successfully enters their email and password, if MFA is enabled for their account, they are prompted to enter the current TOTP code from their authenticator app.
The server verifies the submitted TOTP code against the expected value generated from the stored secret.
If the code is valid, the user is granted access; otherwise, an error message is shown.
We also provide backup codes that users can use to access their account if they lose access to their authenticator app.
These backup codes are generated during MFA setup and can be used once each.
This implementation enhances account security by requiring a second factor of authentication beyond just the password.

\subsection*{Non functional Requirements}
All non-functional requirements from the user registration module apply here as well. They were omitted for brevity.

\section*{Tech Stack}
All technologies from the user registration module apply here as well. They were also omitted for brevity.

\section*{UML Diagrams}
\subsection*{Login Process}
\includegraphics[width=\textwidth]{img/UML_Login.pdf}

\subsection*{Forgotten Password Process}
\includegraphics[width=\textwidth]{img/UML_ForgottenPassword.pdf}

\subsection*{Password Reset Process}
\includegraphics[width=\textwidth]{img/UML_PasswordReset.pdf}

\end{document}
