\documentclass[11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[margin=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage{svg}
\usepackage{float}
\usepackage{titlesec}

% This removes "Chapter X" and the number, but keeps the Title
\titleformat{\chapter}[hang] 
{\normalfont\huge\bfseries}{}{0pt}{}

\title{Application Security -- Laboratory Report\\[0.4em]
\large LAB-05: Complete Secure Web Application with MFA and Hardened Modules}
\author{Gaillard Théo \\ \texttt{theo.gaillard@student.put.poznan.pl} \\
Quivron Emile \\ \texttt{emile.quivron@student.put.poznan.pl} \\
\\
Supervisor: Michał Apolinarski, Ph.D. \\ Politechnika Poznańska}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage

\chapter*{Introduction}
This report documents the implementation of the previously developped \textit{User Authentication Module}
and associated security layers for a generic application. We decided to build a rather simple forum-like app.
This allows us to implement various types of security measures, ranging from basic granular permissions
to advanced magic-bytes enforcement for file uploads.

The focus of this laboratory was to transition from a basic functional authentication module to a hardened,
production-ready application by applying industry-standard security patterns throughout the application.

We used Tailwind CSS to quickly prototype a clean and responsive user interface. However, the main focus was of course
on backend security. We are using Flask as the web framework, SQLite for data persistence, and various Python libraries
to implement security features such as password hashing, CSRF protection, and MFA.

\part{Architecture and Design Principles}

\chapter{Core Security Principles}
The following guiding principles were strictly followed during the implementation phase to ensure a defense-in-depth approach.

\section{Zero-Trust Input Validation}
All data originating from the client-side is treated as untrusted. Every input is subjected to a three-step process:
\begin{enumerate}
    \item \textbf{Validation}: Ensuring data conforms to expected types, lengths, and formats (e.g., regex for emails).
    \item \textbf{Sanitization}: Stripping potentially harmful characters to prevent injection attacks.
    \item \textbf{Constraint Enforcement}: Restricting inputs to explicit allowlists (e.g., specific MIME types for uploads).
\end{enumerate}
We utilized libraries such as \texttt{python-magic} for file type validation and WTForms for form input validation. This
ensures that industry-standard validation techniques are applied consistently, and reduces the risk of common vulnerabilities.

\section{Security-First Development Lifecycle}
Development followed a strict "Security-by-Design" sequence:
\begin{itemize}
    \item \textbf{Baseline Security}: Authentication, authorization, and safe persistence were implemented alongside business logic.
    \item \textbf{UX Refinement}: User flows were \textit{"optimized"} only after ensuring that usability did not compromise security invariants.
    \item \textbf{Regression Testing}: Every change was verified to ensure it did not bypass existing security middleware.
\end{itemize}

\part{Module-Level Security Mapping}

\chapter{Core Application and Routing}
This section describes the global security configuration applied to the application base.

\section{Route Surface}
\begin{itemize}[leftmargin=1.5em]
    \item \texttt{/} -- Public; utilizes \texttt{already\_logged\_in} to redirect authenticated users.
    \item \texttt{/dashboard} -- Authenticated; protected by \texttt{login\_required}.
    \item \textbf{Global Error Handlers} -- Custom 404/500 pages to prevent stack-trace leakage.
\end{itemize}

\section{Security Controls}
\begin{itemize}[leftmargin=1.5em]
    \item \textbf{CSRF Protection}: \texttt{CSRFProtect} is enabled globally. Every state-changing request (POST/PUT/DELETE) requires a valid, synchronized token.
    \item \textbf{Session Management}: The \texttt{SECRET\_KEY} is used to sign session cookies. Sessions are regenerated upon login and cleared upon logout to prevent session fixation and hijacking.

          \textit{Note: the secret key should be rotated periodically and at every restart of the application in a production environment. We did not implement this here on purpose to keep our sessions persistent during development.}
\end{itemize}

\chapter{Authentication and MFA (\texttt{auth} module)}
The authentication module handles the identity lifecycle, including registration and Multi-Factor Authentication (MFA).

\section{Route Surface}
\begin{itemize}[leftmargin=1.5em]
    \item \texttt{/register}, \texttt{/login}, \texttt{/activate/<token>} -- Public-facing entry points.
    \item \texttt{/mfa/setup}, \texttt{/mfa/confirm} -- MFA configuration (authenticated).
    \item \texttt{/mfa/verify} -- Gated pre-authentication stage using \texttt{pre\_auth\_user\_id}.
\end{itemize}

\section{Security Implementation}
\begin{itemize}[leftmargin=1.5em]
    \item \textbf{Cryptographic Hashing}: Passwords are never stored in plaintext. We utilize Werkzeug's \texttt{generate\_password\_hash()} method with unique salts for every user.    \item \textbf{Account Activation}: New accounts remain in a "Pending" state until email verification. Activation tokens are server-side managed with strict expiration timestamps.
    \item \textbf{Brute-Force Mitigation}: Failed login and MFA attempts are rate-limited. After three failed attempts, the account flow triggers a mandatory reset or lockout period.
    \item \textbf{MFA Gating}: MFA implementation utilizes TOTP (Time-based One-Time Passwords). During the login process, a user is held in a "pre-authenticated" state, where session permissions are strictly limited until the second factor is verified.
\end{itemize}

\chapter{Content and Media (\texttt{content} module)}
This module manages the core business logic of the MicroBlog: posts, comments, and file attachments.

\section{Route Surface}
\begin{itemize}[leftmargin=1.5em]
    \item \texttt{/content/feed} -- Public visibility of approved posts.
    \item \texttt{/content/post/create}, \texttt{/edit}, \texttt{/delete} -- Owner-restricted CRUD operations.
    \item \texttt{/content/attachment/<id>} -- Permission-gated binary delivery.
\end{itemize}

\section{Security Implementation}
\begin{itemize}[leftmargin=1.5em]
    \item \textbf{Granular Authorization}: Access control is centralized in \texttt{permissions.py}. The system verifies that the current \texttt{user\_id} matches the resource \texttt{owner\_id} before allowing modifications.
    \item \textbf{Secure File Uploads}:
          \begin{itemize}
              \item \textbf{Magic Byte Validation}: MIME types are verified by reading the file header, not just the extension.
              \item \textbf{Storage Isolation}: Files are renamed using \texttt{secure\_filename} and stored outside the web root.
              \item \textbf{Delivery}: Files are served via \texttt{send\_from\_directory} with forced \texttt{Content-Disposition: attachment}.
          \end{itemize}
\end{itemize}

\chapter{User Management (\texttt{user} module)}
Handles profile management and administrative oversight.

\section{Security Implementation}
\begin{itemize}[leftmargin=1.5em]
    \item \textbf{Destructive Action Verification}: Deleting or disabling an account requires a re-authentication step (password confirmation) and an explicit string confirmation (e.g., typing "DELETE").
    \item \textbf{Administrative Safeguards}: Admins cannot disable their own accounts to prevent accidental total lockout of the system.
    \item \textbf{Account State Persistence}: A distinction is made between user-initiated "disabling" and admin-initiated "banning." Users can self-reactivate, whereas admin bans require administrative intervention.
\end{itemize}

\end{document}