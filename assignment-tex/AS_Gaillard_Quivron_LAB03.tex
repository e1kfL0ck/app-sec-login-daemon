\documentclass[11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[margin=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage{svg}

\title{Application Security -- Laboratories -- LAB03\\[0.5em]
\large User registration process (Part A)}
\author{Gaillard Théo \\ \texttt{theo.gaillard@student.put.poznan.pl} \\
Quivron Emile \\ \texttt{emile.quivron@student.put.poznan.pl} \\
\\
Supervisor: Michał Apolinarski, Ph.D. \\ Politechnika Poznańska}
\date{\today}

\begin{document}
\maketitle

\section*{Component Short Description}
The user registration module is a secure software component responsible for creating new user accounts within the system.
Its primary purpose is to allow new users to provide personal and authentication information, validate that information securely on the server side, and store the finalized account data in the application database.

\subsection*{Collected data}
The component collects the following data from the user during registration:
\begin{itemize}
  \item Email address -- used as the unique identifier for the account and for sending activation tokens.
  \item Password -- chosen by the user and processed using strong hashing before storage.
  \item Optional user metadata -- such as username or full name, depending on system requirements.
\end{itemize}

\subsection*{Security assumptions and objectives}
\begin{itemize}
  \item The server is assumed to operate over a secure HTTPS channel to ensure confidentiality during transmission.
  \item All data submitted by users is considered untrusted and must be validated server-side to prevent injection attacks, malformed input, or exploitation attempts.
  \item Passwords must never be stored in plain text; they are protected using a secure one-way hashing function with salting.
  \item A unique activation token is generated for each new registration to confirm ownership of the provided email address.
  \item The module supports error handling and defensive measures throughout the process, including input validation, token verification, storage integrity constraints, and optional security hardening (rate limiting, advanced password policies, and event logging).
\end{itemize}

\section*{Component Requirements}
\subsection*{Functional Requirements}
\begin{description}
  \item [FR-01] The system must provide a user registration form for entering required data.
  \item [FR-02] The server must validate all submitted fields for correctness, integrity, and constraints.
  \item [FR-03] The system must verify that the email address is not already registered.
  \item [FR-04] The system must hash passwords securely before storing them.
  \item [FR-05] The system must generate a unique account activation token after registration.
  \item [FR-06] The system must send an activation link containing the token to the user’s email address.
  \item [FR-07] The system must activate the account by validating the token upon request.
  \item [FR-08] The system must handle invalid or expired tokens with clear error messages.
  \item [FR-09] The module must store user data (email, hashed password, token status, timestamps).
  \item [FR-10] The system should log validation or activation errors.
\end{description}

\subsection*{Optional Functional Requirements (Bonus Features)}
\begin{description}
  \item [OFR-01] Display a password strength meter during user input.
  \item [OFR-02] Enforce an advanced password policy (length, complexity, blacklist, etc.).
  \item [OFR-03] Perform email verification through DNS MX lookup or SMTP handshake.
  \item [OFR-04] Apply email domain restrictions via whitelist or blacklist.
  \item [OFR-05] Support registration using invitation tokens.
  \item [OFR-06] Implement CAPTCHA or rate limiting to prevent automated or abusive submissions.
  \item [OFR-07] Improve activation token security (short lifetime, association with device/IP, etc.).
  \item [OFR-08] Log successful and failed registration attempts as security events.
\end{description}

\subsection*{Non-Functional Requirements}
\paragraph{Security Requirements}
\begin{description}
  \item [NFR-S01] Passwords must be stored using secure, modern cryptographic hashingitemize.
  \item [NFR-S02] Sensitive information (passwords, tokens) must not be logged.
  \item [NFR-S03] All communication between client and server should use HTTPS.
\end{description}

\paragraph{Usability Requirements}
\begin{description}
  \item [NFR-U01] Error and validation messages from the frontend must be clear and user-friendly.
  \item [NFR-U02] Registration should require no more than one user interaction step before activation.
\end{description}

\paragraph{Performance Requirements}
\begin{description}
  \item [NFR-P01]: Registration requests should be processed with low latency.
  \item [NFR-P02]: The system should scale to the required number of concurrent registrations.
\end{description}

\paragraph{Reliability Requirements}
\begin{description}
  \item [NFR-R01]: Duplicate account creation with the same email must be prevented.
  \item [NFR-R02]: Activation tokens must have a configurable expiration period.
  \item [NFR-R03]: Token validation must fail safely in cases of expiration or tampering.
\end{description}

\paragraph{Maintainability Requirements}
\begin{description}
  \item [NFR-M01]: The module must be structured with separate layers for validation, logic, and data access.
  \item [NFR-M02]: Configuration values must be stored in an accessible JSON configuration file.
\end{description}

\section*{Tech Stack}
\subsection*{Frontend}
\begin{itemize}
  \item HTML5 and CSS3: For building the registration and activation pages.
  \item JavaScript: Handles client-side input validation (email format, password strength meter, etc.).
  \item Optional: Bootstrap or TailwindCSS for quick UI styling and responsive layouts.
\end{itemize}

\subsection*{Backend}
\begin{itemize}
  \item Python 3: Core application logic and registration workflows run here.
  \item Flask: Web framework for routing (e.g., \texttt{POST /register} and \texttt{GET /activate/<token>}), input validation, and returning HTML or JSON responses.
\end{itemize}

\subsection*{Security \& Cryptography}
\begin{itemize}
  \item \texttt{bcrypt}: For secure password hashing with salt.
  \item \texttt{secrets} (Python standard library): For generating secure random activation tokens.
\end{itemize}

\subsection*{Database}
\begin{itemize}
  \item SQLite3: local file-based relational database accessed using Python's built-in \texttt{sqlite3} module.
  \item Example tables and columns:
        \begin{itemize}
          \item \texttt{users}: \texttt{id}, \texttt{email}, \texttt{password\_hash}, \texttt{created\_at}, \texttt{activated} (boolean)
          \item \texttt{activation\_tokens}: \texttt{token}, \texttt{user\_id}, \texttt{expires\_at}
        \end{itemize}
  \item Constraints should ensure unique emails, token expiration rules, and referential integrity.
\end{itemize}

\subsection*{Web Server}
\begin{itemize}
  \item \texttt{nginx} as reverse proxy to the Python application (via Gunicorn); serves static files and handles TLS termination.
\end{itemize}

\section*{UML Diagram}
\subsection*{User Form Filling Process}
\includegraphics[width=\textwidth]{img/UML_FormFilling.pdf}

\subsection*{User Registration Process}
\includegraphics[width=\textwidth]{img/UML_Register.pdf}

\subsection*{Token Validation Process}
\includegraphics[width=\textwidth]{img/UML_ActivationToken.pdf}

\section{User registration flow presented}

When a user wants to register on our platform, they will first access the registration page served by our Flask backend. The user fills out the registration form with their email and password. On the client side, JavaScript performs preliminary validation checks, such as ensuring the email format is correct and the password meets basic strength requirements. This immediate feedback enhances user experience by catching simple errors before submission.

Here's an example of the potential errors :

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{img/registration_errors_client.png}
  \caption{Example of validation error messages shown to the user during registration (email format, password strength, and required fields).}
  \label{fig:registration_errors}
\end{figure}

Once the user submits the form, the data is sent via a POST request to the Flask backend at the \texttt{/register} endpoint. The backend performs comprehensive server-side validation to ensure all fields are correct. This includes checking that the email format is valid, it does not contain dangerous patterns (to prevent injection attacks), verifying that the password meets security policies (length, complexity). Then, the backend will try to save this new user in the database, ensuring the email is unique. The database also contains the user activation status. If any validation fails, the backend responds with appropriate error messages, which are then displayed to the user.

If the email is already registered here's an example of the error message shown to the user :

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{img/registration_error_email_exists.png}
  \caption{Example of error message shown to the user when trying to register with an already registered email.}
  \label{fig:registration_error_email_exists}
\end{figure}

Upon successful validation and user creation, the backend generates a unique activation token using Python's \texttt{secrets} module. This token is stored in the database along with an expiration timestamp and the user id associated with it. This token is then displayed in the frontend for demonstration purposes (in a future version, the token will be sent via email, according to the requirements).

Example of token being displayed to the user after successful registration :
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{img/registration_success_token.png}
  \caption{Example of activation token displayed to the user after successful registration.}
  \label{fig:registration_success_token}
\end{figure}

When the user clicks the activation link, it sends a GET request to the \texttt{/activate/<token>} endpoint on the backend. The backend retrieves the token from the URL, validates it against the database (checking for existence and expiration), and if valid, updates the user's activation status to true. The user is then informed of the successful activation.

Example of successful activation message shown to the user :
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{img/activation_success.png}
  \caption{Example of successful activation message shown to the user.}
  \label{fig:activation_success}
\end{figure}

If the token is invalid or expired, the backend responds with an error message, which is displayed to the user.

Example of error message shown to the user when trying to activate with an invalid or expired token :
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{img/invalid_token.png}
  \caption{Example of error message shown to the user when trying to activate with an invalid or expired token.}
  \label{fig:activation_error_invalid_token}
\end{figure}


\section*{Why Validate on Both Frontend and Backend}

In the user registration process, we implement validation checks on both the frontend (client-side) and backend (server-side) for complementary reasons. Frontend validation provides immediate user feedback, improving UX by catching simple errors like password length or format issues before submission. It reduces unnecessary server requests and guides users to correct their input quickly.

However, frontend checks can be bypassed---attackers can disable JavaScript or manipulate requests directly. Backend validation is our security layer, defending against SQL injection, XSS, and malicious payloads. It enforces business rules and data integrity regardless of client behavior.

For example, our \texttt{validation.js} validates email format client-side:
\begin{verbatim}
const re = /^[^@\s]+@[^@\s]+\.[^@\s]+$/;
if (!re.test(email)) {
    errors.push("Email format is invalid.");
}
\end{verbatim}

While our \texttt{app.py} backend sanitizes and re-validates server-side:
\begin{verbatim}
def sanitize_user_input(field_value: str, max_len: int = 255):
    if contains_dangerous_pattern(field_value):
        errors.append("User input error.")
\end{verbatim}

The frontend enhances usability; the backend ensures security. Both working together create a robust system: fast feedback for legitimate users, strong protection against attackers. Never trust client-side validation alone---our backend is the final authority.

\end{document}
